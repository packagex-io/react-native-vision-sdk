package io.packagex.visionsdk.ui.activities

import android.content.Intent
import android.graphics.Bitmap
import android.graphics.Color
import android.graphics.RectF
import android.graphics.drawable.GradientDrawable
import android.os.Bundle
import android.util.Size
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import androidx.activity.addCallback
import androidx.activity.enableEdgeToEdge
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCaptureException
import androidx.camera.core.ImageProxy
import androidx.camera.core.Preview
import androidx.camera.core.UseCaseGroup
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.content.ContextCompat
import androidx.core.graphics.toRectF
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.isVisible
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.lifecycleScope
import com.asadullah.handyutils.gone
import com.asadullah.handyutils.invisible
import com.asadullah.handyutils.isNeitherNullNorEmptyNorBlank
import com.asadullah.handyutils.launchOnIO
import com.asadullah.handyutils.toDp
import com.asadullah.handyutils.toNullIfEmptyOrBlank
import com.asadullah.handyutils.visible
import com.asadullah.handyutils.withContextMain
import com.google.android.material.imageview.ShapeableImageView
import io.packagex.visionsdk.R
import io.packagex.visionsdk.analyzers.BarcodeResult
import io.packagex.visionsdk.analyzers.FullScreenImageAnalyzer
import io.packagex.visionsdk.analyzers.ImageScanner
import io.packagex.visionsdk.interfaces.CameraXBarcodeCallbackAdapter
import io.packagex.visionsdk.preferences.VisionSDKSettings
import io.packagex.visionsdk.preferences.dto.BarcodeTemplate
import io.packagex.visionsdk.preferences.dto.BarcodeTemplateData
import io.packagex.visionsdk.utils.BitmapUtils
import io.packagex.visionsdk.utils.LinearConversion
import io.packagex.visionsdk.utils.isEmulator
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.concurrent.Executor
import java.util.concurrent.Executors
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import kotlin.coroutines.suspendCoroutine
import kotlin.math.max
import kotlin.math.roundToInt

internal class CreateTemplateActivity : AppCompatActivity() {

    private val rootView by lazy {
        findViewById<ViewGroup>(R.id.rootView)
    }

    private val cameraPreviewView by lazy {
        findViewById<PreviewView>(R.id.cameraPreviewView)
    }

    private val saveProgressView by lazy {
        findViewById<View>(R.id.saveProgressView)
    }

    private val cancelButton by lazy {
        findViewById<View>(R.id.cancelButton)
    }

    private val saveButton by lazy {
        findViewById<View>(R.id.saveButton)
    }

    private val subtitleView by lazy {
        findViewById<View>(R.id.subtitleView)
    }

    private val freezeButton by lazy {
        findViewById<Button>(R.id.freezeButton)
    }

    private val imageView by lazy {
        findViewById<ShapeableImageView>(R.id.imageView)
    }

    private val cameraExecutor = Executors.newSingleThreadExecutor()

    private val imageCaptureUseCase by lazy { ImageCapture.Builder().build() }

    private val barcodeBoundingBoxesMap = mutableMapOf<String, View>()

    private val selectedBarcodes = mutableListOf<BarcodeResult>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContentView(R.layout.activity_create_template)
        ViewCompat.setOnApplyWindowInsetsListener(rootView) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }

        cancelButton.setOnClickListener {
            setResult(RESULT_CANCELED)
            finish()
        }

        onBackPressedDispatcher.addCallback {
            cancelButton.callOnClick()
        }

        saveButton.setOnClickListener {

            saveProgressView.visible()
            saveButton.invisible()

            lifecycleScope.launchOnIO {

                val allTemplates = VisionSDKSettings.getAllBarcodeTemplates()
                var index = 1
                var autoGeneratedName = "Template $index"
                while (true) {
                    if (allTemplates.map { it.name }.contains(autoGeneratedName)) {
                        index++
                        autoGeneratedName = "Template $index"
                    } else {
                        break
                    }
                }

                VisionSDKSettings.saveBarcodeTemplate(
                    BarcodeTemplate(
                        autoGeneratedName,
                        selectedBarcodes
                            .filter {
                                it.barcode.displayValue.isNeitherNullNorEmptyNorBlank()
                            }
                            .map {
                                BarcodeTemplateData(
                                    barcodeLength = it.barcode.displayValue!!.length,
                                    barcodeFormat = it.barcode.format
                                )
                            }
                    )
                )

                withContextMain {
                    saveProgressView.gone()
                    setResult(
                        RESULT_OK,
                        Intent().apply {
                            putExtra("RET_CREATED_TEMPLATE", autoGeneratedName)
                        }
                    )
                    finish()
                }
            }
        }

        freezeButton.setOnClickListener {

            if (imageView.isVisible) {
                selectedBarcodes.clear()
                imageView.gone()
                subtitleView.gone()
                freezeButton.text = "Freeze"
                clearBoundingBoxMap()
                startCamera()
                return@setOnClickListener
            }

            lifecycleScope.launch {
                try {
                    val capturedImage = takePicture(cameraExecutor, imageCaptureUseCase)
                    imageView.visible()
                    imageView.setImageBitmap(capturedImage)
                    subtitleView.visible()
                    freezeButton.text = "Retake"
                } catch (e: Exception) {
                    e.printStackTrace()
                }
                withContext(Dispatchers.Main) {
                    getCameraProvider().unbindAll()
                }
            }
        }

        startCamera()
    }

    private val imageAnalyzer = FullScreenImageAnalyzer(
        ImageScanner(
            allInitialBarcodes = { it },
            object : CameraXBarcodeCallbackAdapter() {

                override fun aggregatedBarcodeResults(barcodes: List<BarcodeResult>) {

                    if (barcodes.isEmpty()) {
                        clearBoundingBoxMap()
                        return
                    }

                    barcodes.forEach { barcodeResult ->

                        barcodeResult.barcode.displayValue.toNullIfEmptyOrBlank() ?: return@forEach

                        if (barcodeBoundingBoxesMap.containsKey(barcodeResult.barcode.displayValue).not()) {
                            barcodeBoundingBoxesMap[barcodeResult.barcode.displayValue!!] = View(this@CreateTemplateActivity)
                                .apply {
                                    tag = barcodeResult
                                    setOnClickListener {

                                        // If user has not captured any picture yet, then clicking on these
                                        // bounding boxes should not do anything. For checking if user has
                                        // taken a picture or not, we're using if imageView is visible or not.
                                        if (imageView.isVisible.not()) return@setOnClickListener

                                        if (selectedBarcodes.contains(barcodeResult)) {
                                            selectedBarcodes.remove(barcodeResult)
                                        } else {
                                            selectedBarcodes.add(barcodeResult)
                                        }
                                        setBoundingBoxColors(this)
                                        saveButton.isEnabled = selectedBarcodes.isNotEmpty()
                                    }
                                }
                                .also { rootView.addView(it) }
                        }

                        val boundingBoxView = barcodeBoundingBoxesMap[barcodeResult.barcode.displayValue] ?: return@forEach
                        val rectF = barcodeResult.barcode.boundingBox?.toRectF() ?: return@forEach

                        val widthConversion = LinearConversion(
                            0.0F,
                            barcodeResult.imageHeight.toFloat(),
                            0.0F,
                            cameraPreviewView.width.toFloat()
                        )
                        val newLeft = widthConversion.getValueAgainst(rectF.left)
                        val newRight = widthConversion.getValueAgainst(rectF.right)

                        val heightConversion = LinearConversion(
                            0.0F,
                            barcodeResult.imageWidth.toFloat(),
                            0.0F,
                            cameraPreviewView.height.toFloat()
                        )
                        val newTop = heightConversion.getValueAgainst(rectF.top)
                        val newBottom = heightConversion.getValueAgainst(rectF.bottom)

                        val translatedRectF = RectF(newLeft, newTop, newRight, newBottom)

                        boundingBoxView.x = translatedRectF.left
                        boundingBoxView.y = translatedRectF.top

                        val params = boundingBoxView.layoutParams as ConstraintLayout.LayoutParams
                        params.width = translatedRectF.width().roundToInt()
                        params.height = max(translatedRectF.height().roundToInt(), toDp(200))

                        boundingBoxView.layoutParams = params

                        setBoundingBoxColors(boundingBoxView)
                    }

                    val stringsOfBarcodes = barcodes.map { it.barcode.displayValue }
                    val keysToBeRemoved = barcodeBoundingBoxesMap.keys.filter { stringsOfBarcodes.contains(it).not() }

                    // Now remove all the keys that should be removed from boundingBoxesMap,
                    // as well as from this layout.
                    keysToBeRemoved.forEach {
                        val viewToBeRemoved = barcodeBoundingBoxesMap.remove(it)
                        rootView.removeView(viewToBeRemoved)
                    }
                }

                private fun setBoundingBoxColors(boundingBoxView: View) {
                    boundingBoxView.background = GradientDrawable().apply {
                        shape = GradientDrawable.RECTANGLE
                        val barcodeResultInThisView = boundingBoxView.tag as BarcodeResult
                        val isSelected = selectedBarcodes.contains(barcodeResultInThisView)
                        setColor(if (isSelected) Color.argb(0.4f, 0f, 1f, 0f) else Color.argb(0.4f, 0.6f, 0.6f, 0.6f))
                        setStroke(toDp(12), if (isSelected) Color.GREEN else Color.DKGRAY)
                    }
                }
            }
        ).apply {
            this.enableTextDetection(false)
            this.scanningModeManual(true)
            this.multipleScanEnabled(true)
        }
    ).apply {
        analyzeEveryFrame()
    }

    private fun startCamera() {

        lifecycleScope.launch {
            val cameraProvider = getCameraProvider()

            val analysis = ImageAnalysis
                .Builder()
                .setTargetResolution(Size(cameraPreviewView.width, cameraPreviewView.height))
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .setOutputImageFormat(ImageAnalysis.OUTPUT_IMAGE_FORMAT_YUV_420_888)
                .build()
                .apply {
                    if (isEmulator().not()) {
                        setAnalyzer(cameraExecutor, imageAnalyzer)
                    }
                }

            val previewUserCase = Preview
                .Builder()
                .build()
                .apply {
                    setSurfaceProvider(cameraPreviewView.surfaceProvider)
                }

            val cameraxSelector = CameraSelector
                .Builder()
                .requireLensFacing(CameraSelector.LENS_FACING_BACK)
                .build()

            cameraProvider.bindToLifecycle(
                this@CreateTemplateActivity as LifecycleOwner,
                cameraxSelector,
                UseCaseGroup.Builder()
                    .addUseCase(previewUserCase)
                    .addUseCase(analysis)
                    .addUseCase(imageCaptureUseCase)
                    .setViewPort(cameraPreviewView.viewPort!!)
                    .build()
            )
        }
    }

    private fun clearBoundingBoxMap() {
        barcodeBoundingBoxesMap.forEach {
            rootView.removeView(it.value)
        }
        barcodeBoundingBoxesMap.clear()
    }

    private suspend fun getCameraProvider(): ProcessCameraProvider =
        suspendCoroutine { continuation ->
            ProcessCameraProvider.getInstance(this@CreateTemplateActivity).also { cameraProvider ->
                cameraProvider.addListener({
                    continuation.resume(cameraProvider.get())
                }, ContextCompat.getMainExecutor(this@CreateTemplateActivity))
            }
        }

    private suspend fun takePicture(executor: Executor, imageCaptureUseCase: ImageCapture): Bitmap {
        return suspendCoroutine {

            imageCaptureUseCase.takePicture(executor, object : ImageCapture.OnImageCapturedCallback() {

                override fun onCaptureSuccess(imageProxy: ImageProxy) {
                    it.resume(
                        BitmapUtils.rotateBitmap(
                            bitmap = Bitmap.createBitmap(
                                imageProxy.toBitmap(),
                                imageProxy.cropRect.left,
                                imageProxy.cropRect.top,
                                imageProxy.cropRect.width(),
                                imageProxy.cropRect.height()
                            ),
                            rotationDegrees = 90
                        )
                    )
                }

                override fun onError(exception: ImageCaptureException) {
                    exception.printStackTrace()
                    it.resumeWithException(exception)
                }
            })
        }
    }
}